#summary Sychronization Logic

= Synchronization Logic =

The following outlines of OneSync synchronization algorithm and logic.

  * [SyncLogic#1._Overview 1. Overview]
  * [SyncLogic#2._Sync_Preview 2. Sync Preview]
  * [SyncLogic#3._Applying_Patch 3. Applying Patch]
    * [SyncLogic#3.1_Executing_SyncActions 2.1 Executing SyncActions]
    * [SyncLogic#3.2_Updating_of_metadata 2.2 Updating of metadata]
  * [SyncLogic#4._Generating_Patch 4. Generating Patch]
    * [SyncLogic#4.1_Comparing_Metadata 4.1 Comparing Metadata]
    * [SyncLogic#4.2_Creating_SyncActions 4.2 Creating SyncActions]
    * [SyncLogic#4.3_Rename_Detection 4.3 Rename Detection]
  * [SyncLogic#5._Final_Notes 5. Final Notes]

= 1. Overview =

The following are 2 videos which briefly explain the idea of light-weight synchronization:

_High-resolution video file with manual advance:
  * [https://onesync.googlecode.com/svn/wiki/vid_logic.mov Sync Logic]
  * [https://onesync.googlecode.com/svn/wiki/vid_dropbox.mov Dropbox Sync]
_

<wiki:video url="http://www.youtube.com/watch?v=gjbebQHzLwA&fmt=18&rel=0"/>

It turns out that if DropBox (another layer of synchronization) is used as the intermediary storage, the synchronization logic is still valid.

<wiki:video url="http://www.youtube.com/watch?v=__ENL2TbtQM&fmt=18&rel=0"/>


!FileSyncAgent is the main class executing the synchronization. The code snippet for synchronization is as follows:

{{{
public void Synchronize(SyncPreviewResult preview)
{
    OnStatusChanged(new SyncStatusChangedEventArgs("Applying patch"));
    ApplyPatch(preview);
    SyncEmptyFolders();
    OnStatusChanged(new SyncStatusChangedEventArgs("Generating patch"));
    GeneratePatch();
    OnSyncCompleted(new SyncCompletedEventArgs());
}
}}}

To support Synchronization Preview, the Synchronize method takes in a !SyncPreviewResult as an argument. !SyncPreviewResult is a wrapper for all actions that are to be executed and may contains skipped actions depending on the user selection during the preview.

As OneSync doesn't view folders as items to be synchronized initially, `SyncEmptyFolders()` was added subsequently to achieve this. Of course, if synchronization of empty folders is not required, the method can be removed without any consequence.

= 2. Sync Preview =

The instance method for !FileSyncAgent to generate the !SyncPreviewResult is as follows:

{{{
public SyncPreviewResult GenerateSyncPreview()
}}}

For each !SyncAction to be executed, the affected file is checked if it was modified since the last sync. This is done by comparing the file with the metadata created during the last sync. If it has been changed, the !SyncAction will be considered as a conflict. The !SyncAction has a Conflict Resolution property/field to determine how this conflict is going to be resolved. It is to be noted that there will be no further filesystem changes made to the sync folder by OneSync after all !SyncActions are executed.

It is during generation of !SyncPreviewResult that conflicts are detected and filtered out.

Outline of preview generation:
  * `actions = load all SyncActions`
  * `currentItems = generate sync folder metadata`
  * `oldCurrentItems = load previously saved sync folder metadata`
  * `oldOtherItems = load metadata of other PC for comparison`

Sequence diagram for `GenerateSyncPreviewResult()`:

[http://onesync.googlecode.com/svn/wiki/images/sd_genPreview.png]


= 3. Applying Patch =

When synchonization starts, OneSync will check if there is any patch to apply to the current folder that is being synced. A Patch conceptually refers to !SyncActions to be executed and the (dirty) files that are associated with these !SyncActions.

Code snippet for `ApplyPatch()`:

{{{
private void ApplyPatch(SyncPreviewResult previewResult)
{
    /* Instantiates logging */
    ExecuteCreateActions(previewResult.ItemsToCopyOver);
    ExecuteDeleteActions(previewResult.ItemsToDelete);
    ExecuteRenameActions(previewResult.ItemsToRename);
    ExecuteConflictActions(previewResult.ConflictItems);
    /* Do logging */
}
}}}

== 3.1 Executing !SyncActions ==

Each !SyncAction can be a Copy, Delete or Rename action. 

After the !SyncActions are executed, the !SyncActions and any associated files are deleted from the intermediary storage as they are no longer required.

== 3.2 Updating of metadata =

As the actions are being executed, the corresponding metadata will be updated as well. This is to allow for comparison by the other PC for detection of the dirty files (i.e. files changed since last synchronization is run).

= 4. Generating Patch =

This is the stage where the !SyncActions for the other folder/PC is being generated.

== 4.1 Comparing Metadata ==

The saved metadata of the other PC is being compared with the current filesystem of the file being synchronized. The purpose is to detect all the differences between the filesystem of the folder that is being synchronized and the filesystem of the other PC.

The `FileMetaDataComparer` class is used to determine the differences between 2 !FileMetaData (labelled _left_ and _right_). The result of the comparison comprises of 3 lists:
  * Files that exists in the left only
  * Files that exists in the right only
  * Files that exists in both but are modified

LINQ is used to express the above queries:

{{{
var rightOnly = from i in right.MetaDataItems
                where !left.MetaDataItems.Contains(i, comparer)
                select i;

var leftOnly = from i in left.MetaDataItems
               where !right.MetaDataItems.Contains(i, comparer)
               select i;

var both = from l in left.MetaDataItems
           join r in right.MetaDataItems
           on l.RelativePath equals r.RelativePath
           where l.HashCode != r.HashCode
           select l;
}}}

Of course, the above might not be the most efficient query. There is still room for optimization of the search.

== 4.2 Creating !SyncActions ==

For each difference, a corresponding !SyncAction will be generated to resolve this difference. In this stage only files in the current PC could be associated with a !SyncAction. These !SyncActions, together with its associated file (if any) can be considered to be the patch for other PC.

== 4.3 Rename Detection ==

A Rename action is seen to be equivalent to a Delete action followed by a Create action of the same file. Therefore, Rename actions are generated last. In current implementation, the File Hash is used to determine whether the deleted and created file are the same (and hence constitute a rename action).

It is to be noted that for this implementation, the user might not have renamed the file but has explicitly deleted it and created a same file with the same contents (and hence the same hash). However, !OneSync will still detect it as a rename operation and after synchronization, the state of the filesystem will still be consistent.

A possible solution might be to use the unique Id of a file. See [FutureImprovements Future Improvements] for more details.

=== 5. Final Notes ===
Due to the nature of light-weight sync, several rounds of synchronization will be required for 2 folders to be synchronized.

For instance, after 2 folders are synchronized, if both folders are modified (files are created, renamed etc in both folders), another 2 synchronization needs to be carried out for changes in either folder to be propagated to each other. This is how synchronization in OneSync differs from conventional synchronization.