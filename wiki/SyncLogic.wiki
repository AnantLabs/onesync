#summary Sychronization Logic

= Synchronization Logic =

The following outlines of OneSync synchronization algorithm and logic.

  * [SyncLogic#1._Overview 1. Overview]
  * [SyncLogic#2._Sync_Preview 2. Sync Preview]
  * [SyncLogic#3._Applying_Patch 3. Applying Patch]
    * [SyncLogic#3.1_Executing_SyncActions 2.1 Executing SyncActions]
    * [SyncLogic#3.2_Updating_of_metadata 2.2 Updating of metadata]
  * [SyncLogic#4._Generating_Patch 4. Generating Patch]
    * [SyncLogic#4.1_Comparing_Metadata 4.1 Comparing Metadata]
    * [SyncLogic#4.2_Creating_SyncActions 4.2 Creating SyncActions]

= 1. Overview =

!FileSyncAgent is the main class executing the synchronization. The code snippet for synchronization is as follows:

{{{
public void Synchronize(SyncPreviewResult preview)
{
    OnStatusChanged(new SyncStatusChangedEventArgs("Applying patch"));
    ApplyPatch(preview);
    SyncEmptyFolders();
    OnStatusChanged(new SyncStatusChangedEventArgs("Generating patch"));
    GeneratePatch();
    OnSyncCompleted(new SyncCompletedEventArgs());
}
}}}

To support Synchronization Preview, the Synchronize method takes in a !SyncPreviewResult as an argument. !SyncPreviewResult is a wrapper for all actions to be executed and may contains skipped actions depending on the user selection during the preview.

As OneSync doesn't view folders as items to be synchronized initially, `SyncEmptyFolders()` was added subsequently to achieve this. Of course, if synchronization of empty folders is not required, the method can be removed without any consequence.

= 2. Sync Preview =

The instance method for !FileSyncAgent to generate the !SyncPreviewResult is as follows:

{{{
public SyncPreviewResult GenerateSyncPreview()
}}}

For each !SyncAction to be executed, the affected file is checked whether it was modified since last sync. This is done by comparing the file with the metadata created during last sync. If it has been changed, the !SyncAction will be considered as a conflict action. The !SyncAction has a Conflict Resolution property/field to determine how this conflict is going to be resolved. It is to be noted that there will be no further filesystem changes made to the sync folder by OneSync after all !SyncActions are executed.

It is during generation of !SyncPreviewResult that conflict actions are detected and filtered out.

Outline of preview generation:
  * `actions = load all SyncActions`
  * `currentItems = generate sync folder metadata`
  * `oldCurrentItems = load previously saved sync folder metadata`
  * `oldOtherItems = load metadata of other PC for comparison`

Sequence diagram for `GenerateSyncPreviewResult()`:

[http://www.comp.nus.edu.sg/~deskoh/devGuide/sd_genPreview.png]


= 3. Applying Patch =

When synchonization starts, OneSync will check if there are any patch to be applied to the current folder being synced. A Patch conceptually refers to !SyncActions to be executed and the (dirty) files that are associated with these !SyncActions.

Code snippet for `ApplyPatch()`:

{{{
private void ApplyPatch(SyncPreviewResult previewResult)
{
    /* Instantiates logging */
    ExecuteCreateActions(previewResult.ItemsToCopyOver);
    ExecuteDeleteActions(previewResult.ItemsToDelete);
    ExecuteRenameActions(previewResult.ItemsToRename);
    ExecuteConflictActions(previewResult.ConflictItems);
    /* Do logging */
}
}}}

== 3.1 Executing !SyncActions ==

Each !SyncAction is can be a Copy, Delete or Rename action. 

After the !SyncActions are executed, the !SyncActions and any associated files are deleted from the intermediary storage as they are no longer required.

== 3.2 Updating of metadata =

As the actions are being executed, the corresponding metadata will be updated as well. This is to allow for comparison by the other PC for detection of the dirty files (i.e. files changed since last synchronization is run).

= 4. Generating Patch =

This is the stage where the !SyncActions for the other folder/PC is being generated.

== 4.1 Comparing Metadata ==

The saved metadata of the other PC is being compared with the current filesystem of the file being synchronized. The purpose is to detect all the differences in the filesystem of the folder being synchronized and the filesystem of the other PC.

The `FileMetaDataComparer` class is used to determine the differences between 2 !FileMetaData (labelled _left_ and _right_). The result of the comparison comprises of 3 lists:
  * Files that exists in the left only
  * Files that exists in the right only
  * Files that exists in both but are modified

LINQ is used to expressed the above queries:

{{{
var rightOnly = from i in right.MetaDataItems
                where !left.MetaDataItems.Contains(i, comparer)
                select i;

var leftOnly = from i in left.MetaDataItems
               where !right.MetaDataItems.Contains(i, comparer)
               select i;

var both = from @new in left.MetaDataItems
           join @old in right.MetaDataItems
           on @new.RelativePath equals @old.RelativePath
           where !(@new.HashCode.Equals(@new.HashCode))
           select @new;
}}}

== 4.2 Creating !SyncActions ==

For each difference, a corresponding !SyncAction will be generated to resolve this difference. In this stage only files in the current PC could be associated with a !SyncAction. These !SyncActions, together with its associated file (if any) can be considered to be the patch for other PC.